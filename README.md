# Εργασία εξαμήνου στο μάθημα των Δικτύων Επικοινωνιών: <br> Request-Reply Messaging App
## Stavros Nikolaidis AEM: 3975

Χρησιμοποιήθηκε η τεχνολογία Remote Method Invocation (RMI) για την υλοποίηση της συγκεκριμένης εργασίας

## Κλάσεις

### Message
Η κλάση του μηνύματος. Πέρα από τις απαιτήσεις, έχει προστεθεί το πεδίο `id` για την αποθήκευση 
ενός μοναδικού κωδικού για το κάθε μήνυμα και η μέθοδος `setRead()`
για να αλλάξουμε την κατάσταση ενός μηνύματος σε διαβασμένο.

### Account
Η κλάση του λογαριασμού. Πέρα από τις απαιτήσεις, έχει προστεθεί ο getter ``getMessageBox()``
για εύκολη πρόσβαση στο mailbox του χρήστη.

<ins>Σημείωση:</ins> Οι κλάσεις **Message** και **Account** κάνουν implement το interface `java.io.Serializable`.
Απαραίτητη προϋπόθεση για την χρήση τους στην υλοποίηση της εφαρμογής καθώς αποτελούν τα serializable objects.
### Inter
Το interface της εφαρμογής. Κάνει extend το interface Remote ώστε η υλοποίηση
της εφαρμογής (Βλέπε παρακάτω **MessagingServer**) να είναι remote αντικείμενο.

### MessagingServer
Η υλοποίηση του interface στον server. Κάνει extend την κλάση ``UnicastRemoteObject`` και implement
το interface **Inter** ώστε να μπορέσουμε να υλοποιήσουμε τις 6 μεθόδους που απαιτούνται.
Επίσης, έχει προστεθεί το πεδίο `idCounter` για τη δημιουργία id μηνυμάτων (Βλέπε περισσότερα στις **Υποθέσεις**). 
Πρόσθετα, έχουν υλοποιηθεί οι παρακάτω μέθοδοι για διευκόλυνση της υλοποίησης των 6 λειτουργιών:

* ``void addUser(Account tmp)``: Wrapper κλάση για την εύκολη προσθήκη χρήστη στον server.
* ``String getNameByToken(int token)``: getter για το όνομα του χρήστη δίνοντας ως argument το token του.
* ``boolean checkName(String name)``: Μέθοδος που ελέγχει αν το όνομα ενός χρήστη υπάρχει στον server. Αν υπάρχει επιστρέφει true, αλλιώς false.
* ``boolean checkAuth(int token)``: Μέθοδος που ελέγχει αν το auth token ενός χρήστη υπάρχει στον server. Αν υπάρχει επιστρέφει true, αλλιώς false.

Οι 6 βασικές λειτουργίες έχουν υλοποιηθεί ακριβώς όπως ζητείται από τις απαιτήσεις
της εργασίας. Ότι έχει να σχολιαστεί πάνω σε αυτές αποτελεί υποθέσεις 
(Βλέπε την ανάλογη ενότητα **Υποθέσεις** στο τέλος).

### Server
Υλοποίηση της υπηρεσίας του server. Δημιουργεί μια RMI εγγραφή (registry) ώστε να μπορεί
ο client να χρησιμοποιήσει ο client μέσω του αντικειμένου `stub`. Η υπηρεσία τρέχει για πάντα και περιμένει requests από
τους clients. Η τεχνολογία RMI διαχειρίζεται τα αιτήματα των clients με threads οπότε είμαστε σίγουροι ότι αν γίνουν ταυτόχρονα μερικά requests θα γίνουν όλα.

### Client
Υλοποίηση της υπηρεσίας του client. Συνδέεται με χρήση της παραμέτρου `<port>` στο registry που δημιουργήθηκε από τον server.
Επομένως, παίρνουμε με αναφορά το remote αντικείμενο μέσω του stub αντικειμένου και το χρησιμοποιούμε για να επιλεχθεί
λειτουργία με βάση το argument `<FN_ID>`. Η υπηρεσία τρέχει κάθε φορά που θέλουμε να εκτελέσουμε μια λειτουργία.

## Υποθέσεις

* Υποθέτουμε ότι για να φτιάξουμε τα IDs των μηνυμάτων έχουμε στην κλάση **MessagingServer** έναν μετρητή `idCounter`
  τον οποίο αυξάνουμε για κάθε νέο μήνυμα. Αυτό σημαίνει ότι ένα μήνυμα έχει έναν και μοναδικό κωδικό και αυτό τον κωδικό
  δε θα τον λάβει κανένα άλλο μήνυμα ακόμα και αν το μήνυμα διαγραφτεί.
* Υποθέτουμε ότι η μέθοδος Show Accounts (2) εμφανίζει όλους τα accounts συμπεριλαμβανομένου και του χρήστη που κάλεσε τη μέθοδο.
* Η εφαρμογή μας μπορεί να υποστηρίξει μέχρι 5000 χρήστες. Άμα θέλουμε περισσότερη χωρητικότητα
  τότε πρέπει να αλλάξουμε ένα κομμάτι κώδικα στην κλάση **MessagingServer** στις γραμμές 88 και 90, συγκεκριμένα τον αριθμό 5000 σε ό,τι επιθυμούμε.
* Υποθέτουμε ότι ένας χρήστης μπορεί να στείλει μήνυμα στον εαυτό του.
* Για να προστατέψουμε έναν χρήστη από το να διαβάσουν άλλοι χρήστες τα μηνύματα του, κάνουμε έλεγχο του message id 
  στο mailbox του χρήστη που ζήτησε να διαβάσει μήνυμα και όχι σε όλα τα μηνύματα του server.